
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>APIO2019毒瘤题记录 | Steven_Meng&#39;s Blog</title>
<meta name="description" content="白鳥は　かなしからずや　空の青 海のあをにも　染まずただよふ">
<meta name="referrer" content="no-referrer" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://steven-mhy.github.io/favicon.ico?v=1571467585633">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://steven-mhy.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150421519-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-150421519-1');
</script>


  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://steven-mhy.github.io">
        <img class="avatar" src="https://steven-mhy.github.io/images/avatar.png?v=1571467585633" alt="" width="32px" height="32px">
      </a>
      <a href="https://steven-mhy.github.io">
        <h1 class="site-title">Steven_Meng&#39;s Blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">APIO2019毒瘤题记录</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-08-25</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://steven-mhy.github.io/tag/Z67GTpiNQw6">
                    APIO
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h2 id="t1">T1:</h2>
<p><a href="https://www.luogu.org/problem/P5444">P5444 [APIO2019]奇怪装置</a></p>
<p>其实这题比较简单，考虑两个数对相同的条件：</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;&amp;&#039; at position 16: x_1==x_2 \text{&amp;̲&amp;} y_1==y_2'>x_1==x_2 \text{&amp;&amp;} y_1==y_2</span></p>
<p>设两个数对对应的时刻是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1,t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么我们有</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><mo>⌊</mo><mfrac><msub><mi>t</mi><mn>1</mn></msub><mi>B</mi></mfrac><mo>⌋</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi><mo>=</mo><mo>=</mo><mo>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mo>⌊</mo><mfrac><msub><mi>t</mi><mn>2</mn></msub><mi>B</mi></mfrac><mo>⌋</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>t</mi><mn>1</mn></msub><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>B</mi><mo>=</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>B</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases} (t_1+\lfloor\frac{t_1}{B}\rfloor)\mod A == (t_2+\lfloor\frac{t_2}{B}\rfloor)\mod A \\ t_1\mod B == t_2 \mod B \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8406559999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8406559999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>不妨设$t_1 = i B+j $其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>B</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le j \le B-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>由第二个式子，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>B</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">t_2 \mod B = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>那么我们不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>k</mi><mi>B</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">t_2 = kB+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>带入第一个式子：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mi>B</mi><mo>+</mo><mi>j</mi><mo>+</mo><mi>i</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi><mo>=</mo><mo>=</mo><mo>(</mo><mi>k</mi><mi>B</mi><mo>+</mo><mi>j</mi><mo>+</mo><mi>k</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">(iB+j + i) \mod A == (kB+j+k)\mod A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p>化简一下：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>(</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi><mo>=</mo><mo>=</mo><mo>(</mo><mi>k</mi><mo>(</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>j</mi><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">(i(B+1)+j)\mod A==(k(B+1)+j)\mod A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p>发现左右两边的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>可以消掉：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>(</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi><mo>=</mo><mo>=</mo><mo>(</mo><mi>k</mi><mo>(</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">(i(B+1))\mod A==(k(B+1))\mod A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p>所以两式相等的条件就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>−</mo><mi>j</mi><mo>)</mo><mo>(</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>A</mi><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(k-j)(B+1) \mod A ==0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo>(</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mfrac><mi>A</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">k == j (\mod \frac{A}{gcd(A,B+1)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.392331em;vertical-align:-0.52em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<p>带入原始式子，发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1,t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对应的数对相同的充要条件就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mo>(</mo><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mfrac><mrow><mi>A</mi><mi>B</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">t_1 == t_2 (\mod \frac{AB}{gcd(A,B+1)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.392331em;vertical-align:-0.52em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<p>所以问题转化为线段求并。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 1000005
using namespace std;
inline long long read(){
	long long x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
long long gcd(long long x,long long y){
	return x%y==0?y:gcd(y,x%y);
}
struct Segment{
	long long l,r;
}s[MAXN];
int cnt;
inline void AddSegment(long long l,long long r){
	s[++cnt]=Segment{l,r};
}
inline bool operator &lt; (const Segment &amp;A,const Segment &amp;B){
	return A.l!=B.l?A.l&lt;B.l:A.r&lt;B.r;
}
inline bool operator == (const Segment &amp;A,const Segment &amp;B){
	return A.l==B.l&amp;&amp;A.r==B.r;
}
int main(){
	int n=read();
	long long a=read(),b=read();
	long long M=a/(gcd(a,b+1));
	2e18/M&lt;b?M=2e18:M*=b;
	for (register int i=1;i&lt;=n;++i){
		long long l=read(),r=read();
		if (r-l+1&gt;=M){
			printf(&quot;%lld\n&quot;,M);
			return 0;
		}
		l%=M,r%=M;
		if (l&lt;=r){
			AddSegment(l,r);
		}
		else {
			AddSegment(0,r);
			AddSegment(l,M-1);
		}
	}
	sort(s+1,s+1+cnt);
	cnt=unique(s+1,s+1+cnt)-s-1;
	long long L=s[1].l,R=s[1].r;
	long long ans=0;
	for (register int i=2;i&lt;=cnt;++i){
		if (R&lt;s[i].l) ans+=R-L+1,L=s[i].l,R=s[i].r;
		else R=max(R,s[i].r);
	}
	ans+=R-L+1;
	printf(&quot;%lld\n&quot;,ans);
} 
</code></pre>
<h2 id="t2">T2:</h2>
<p><a href="https://www.luogu.org/problem/P5443">P5443 [APIO2019]桥梁</a></p>
<p>口胡一下部分分做法：</p>
<p>subtask1:大暴力，跑一个bfs即可。</p>
<p>subtask2:用线段树维护一条链，每次二分找出最左/最右边界。</p>
<p>subtask4:离线+并查集，按照边权从大到小，重量从大到小对汽车和桥分别排序，遍历每辆汽车，设其重量是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，将承重能力大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的边全部加入并查集，容易发现并查集是越变越大的，因为汽车重量依次减少，所以它能到达的地方越来越多，大力kruskal重构树也是可以的。</p>
<p>讲一讲正解做法，不妨将暴力和并查集的思路结合在一起，对询问分块，因为桥可能越改越烂，所以并查集的大小不是只增不减的，于是需要支持可撤销。</p>
<p>剩下的部分在代码里面有详细注释</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 200005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
int U[MAXN],V[MAXN],D[MAXN],n,m;
int t[MAXN],s[MAXN],w[MAXN],vis[MAXN];

struct Query{
	int w,s,id;
}q[MAXN];
int cntq;
inline bool operator &lt; (const Query &amp;A,const Query &amp;B){
    return A.w&gt;B.w;
}
inline void AddQuery(int w,int s,int id){
	q[++cntq]=Query{w,s,id};
}

int u[MAXN],cntu;
inline void AddUpdate(int e){
	u[++cntu]=e;
}

struct Edge{
	int w,id;
}e[MAXN];
int cnte;
inline bool operator &lt; (const Edge &amp;A,const Edge &amp;B){
    return A.w&gt;B.w;
}
inline void AddEdge(int w,int i){
	e[++cnte]=Edge{w,i};
}


int tag[MAXN],cnt;
namespace BCJ{
	int fa[MAXN],sz[MAXN];
	int _u[MAXN],_v[MAXN];
	inline void Init_BCJ(){
		for (register int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1;
	}
	int GetFa(int i){
		return fa[i]==i?i:GetFa(fa[i]);
	}
	inline void Union(int i){
		int fau=GetFa(U[i]),fav=GetFa(V[i]);
		if (fau==fav) return ;
		if (sz[fau]&gt;sz[fav]) swap(fau,fav);
		fa[fau]=fav,sz[fav]+=sz[fau];
		_u[i]=fau,_v[i]=fav;//记录修改的点
	}
	inline void Reverse(){//回溯
		for (register int i=cnt;i&gt;=1;--i){
			int from=_u[tag[i]],to=_v[tag[i]];
			_u[tag[i]]=0,_v[tag[i]]=0;
			if (from&lt;0) continue;
			sz[to]-=sz[from],fa[from]=from;
		}
        cnt=0;
	}
}
using namespace BCJ;

int temp[MAXN],ans[MAXN];
inline void Clear(){
	cntu=cntq=cnte=0;
	memset(vis,0,sizeof(vis));
}
int main(){
	n=read(),m=read();
	for (register int i=1;i&lt;=m;++i){
		U[i]=read(),V[i]=read(),D[i]=read();
	}
	int alb=read();
	int Size=1000,lst=1;
	for (register int i=1;i&lt;=alb;++i){
		t[i]=read(),s[i]=read(),w[i]=read();
		if (t[i]==1){//Update s[i]-&gt;w[i]
			if (!vis[s[i]]){
				AddUpdate(s[i]);
				vis[s[i]]=true;//vis[i]==true表示i修改过
			}
		}
		else {//Query
			AddQuery(w[i],s[i],i);
		}
		if (i==alb||i%Size==0){//搞完一个块
			for (register int j=1;j&lt;=m;++j) AddEdge(D[j],j),_u[j]=0;//加入所有边 
			Init_BCJ();
			sort(e+1,e+1+cnte),sort(q+1,q+1+cntq);//按照边权从大到小排序
			int p=1;
			for (register int j=1;j&lt;=cntq;++j){//遍历每个询问
				for (;p&lt;=cnte&amp;&amp;e[p].w&gt;=q[j].w;++p){//没有修改过的边
					int id=e[p].id;
					if (vis[id]) continue;
					Union(id),_u[id]=0;//这条边一定在后面的并查集里面，所以不需要回滚
				}
				for (register int k=lst;k&lt;q[j].id;++k){//lst后面都没有做到
                    int id=s[k];
					if (t[k]==1) temp[id]=1;//标记需要修改的边
				}
				for (register int k=1;k&lt;=cntu;++k){
					int id=u[k];
					if (!temp[id]&amp;&amp;D[id]&gt;=q[j].w) {//没有修改，但是需要回滚，因为后面的操作可能把桥变得更坏
						Union(id),tag[++cnt]=id;
					}
				}
				for (register int k=q[j].id;k&gt;=lst;--k){
					int id=s[k];
					if (t[k]==1) temp[id]=0;//回滚temp数组，所以是倒序
					if (t[k]==2||_u[id]) continue;//如果是query就跳过
					_u[id]=-1,tag[++cnt]=id;//需要回滚
					if (w[k]&gt;=q[j].w) Union(id);//w[k]&gt;=q[j].w对答案可能会有影响
				}
				ans[q[j].id]=sz[GetFa(q[j].s)];//记录答案
				Reverse();//回溯并查集
			}
			for (;lst&lt;=i;++lst){//lst记录修改和查询到哪里
                if (t[lst]==1) D[s[lst]]=w[lst];//把这一块的修改全部做掉，防止影响后面的答案
                else printf(&quot;%d\n&quot;,ans[lst]);
			}
			Clear();//清空
		}
	}
}
</code></pre>
<p>总结：此题的分块做法将暴力可以修改边的性质和离线做法对询问排序的做法结合在一起，十分巧妙。</p>
<h2 id="t3">T3：</h2>
<p><a href="https://www.luogu.org/problem/P5445">P5445 [APIO2019]路灯</a></p>
<p>其实这道题部分分可以拿到60分，现在来详细讲解一下：</p>
<p>subtask1:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>q</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n,q&lt;=100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>暴力，每次暴力复制一份数组：</p>
<pre><code class="language-cpp">namespace BruteForce{
	int a[MAXN][MAXN];
	inline void Copy(int i,int j,int n){//Copy i to j
		for (register int k=1;k&lt;=n;++k){
			a[j][k]=a[i][k];
		}
	}
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0';
		for (register int i=1;i&lt;=q;++i){
			Copy(i-1,i,n);
			if (cmd[i]==0){
				int l=ql[i],r=qr[i];
				int ans=0;
				for (register int j=0;j&lt;i;++j){
					bool flag=false;
					for (register int k=l;k&lt;r;++k){
						if (a[j][k]==0) {
							flag=true;break;
						}
					}
					if (flag==false){
						ans++;
					}
				}
				printf(&quot;%d\n&quot;,ans);
			}
			else {
				int pos=qval[i];
				a[i][pos]=!a[i][pos];
			}
		}
		return 0;
	}
}
</code></pre>
<p>subtask2:这个部分分思维难度比较大，考虑到一个灯的贡献，如果它在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻被点亮，而在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻被熄灭，发现它对答案的贡献是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>−</mo><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_2-t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>不妨记录一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>，代表最后一次这个路灯被点亮/熄灭的时刻，还有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mi>s</mi><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">t \in [1,lst]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a[i]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">ans[i]++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>。</p>
<p>每次Update时这样更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>：</p>
<pre><code class="language-cpp">if (a[pos]==0){
	ans[pos]+=t-lst[pos];
}
lst[pos]=t;
</code></pre>
<p>查询时则是，把前缀和分为两个部分记录：</p>
<pre><code class="language-cpp">ans[l]+(t-lst[l])*a[l]
</code></pre>
<pre><code class="language-cpp">namespace Special_2{
	int lst[MAX];//最后一次这个路灯被点亮/熄灭的时刻
	int ans[MAX],a[MAX];
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0';
		for (register int i=1;i&lt;=n;++i) {
			if (a[i]==1) lst[i]=0;
			else lst[i]=-1;
		}
		for (register int t=1;t&lt;=q;++t){
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				printf(&quot;%d\n&quot;,ans[l]+(t-lst[l])*a[l]);
			}
			else {
				int pos=qval[t];
				a[pos]=!a[pos];
				if (a[pos]==0){
					ans[pos]+=t-lst[pos];
				}
				lst[pos]=t;
			}
		}
		return 0;
	}
}
</code></pre>
<p>subtask3：</p>
<p>对于区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>它全部被点亮的时刻之和，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>所有路灯之中，最后一个被点亮的时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>，用现在时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>即可。</p>
<p>维护一个支持单点覆盖，区间求最大值的线段树即可。</p>
<p>初始化成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，如果查询结果是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>，说明这个区间没有灯被点亮，输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<pre><code class="language-cpp">namespace SegmentTree{
	struct node{
		int l,r;
		int maxn;
	}tree[1000005*4];
	#define lc i&lt;&lt;1
	#define rc i&lt;&lt;1|1
	inline void pushup(int i){
		tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn);
	}
	void Build(int i,int l,int r){
		tree[i].l=l,tree[i].r=r;
		if (l==r){
			tree[i].maxn=0x7fffffff;
			return ;
		}
		int mid=(l+r)&gt;&gt;1;
		Build(lc,l,mid);
		Build(rc,mid+1,r);
		pushup(i);
	}
	void Update(int i,int pos,int val){
		if (tree[i].l==tree[i].r){
			tree[i].maxn=val;
			return ;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1;
		if (pos&lt;=mid) Update(lc,pos,val);
		else Update(rc,pos,val);
		pushup(i);
	}
	int Query(int i,int L,int R){
		if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R){
			return tree[i].maxn;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff;
		if (L&lt;=mid) ans=max(ans,Query(lc,L,R));
		if (mid&lt;R) ans=max(ans,Query(rc,L,R));
		return ans;
	}
}
using namespace SegmentTree;
namespace Special_3{
	inline int Solve(int n,int q){
		//printf(&quot;coming into 3\n&quot;);
		Build(1,1,n);
		for (register int i=1;i&lt;=n;++i){
			if ((s[i]-'0')==1) Update(1,i,0);
		}
		for (register int t=1;t&lt;=q;++t) {
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				int ans=Query(1,l,r-1);
				if (ans==0x7fffffff) puts(&quot;0&quot;);//这条路上面有灯从未被点亮
				else printf(&quot;%d\n&quot;,t-ans); 
			}
			else {
				int i=qval[t];
				Update(1,i,t);
			}
		}
		return 0;
	}
}
</code></pre>
<p>subtask4:不知道怎么搞。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>60</mn><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">60pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span></span></span></span>代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 205
#define MAX 300005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
/*
把询问离线下来 
*/
int cmd[MAX],ql[MAX],qr[MAX],qval[MAX],vis[MAX];
char opr[10],s[MAX];
bool flag2,flag3;
inline void ReadQuerys(int q){
	flag2=flag3=true;
	for (register int i=1;i&lt;=q;++i){
		scanf(&quot;%s&quot;,opr);
		if (opr[0]=='q'){
			cmd[i]=0;
			int l=read(),r=read();
			if (r!=l+1) flag2=false;
			ql[i]=l,qr[i]=r;
		}
		else {
			cmd[i]=1;
			int pos=read();
			if (vis[pos]==1) flag3=false;
			vis[pos]=1;
			qval[i]=pos;
		}
	}
}
namespace SegmentTree{
	struct node{
		int l,r;
		int maxn;
	}tree[1000005*4];
	#define lc i&lt;&lt;1
	#define rc i&lt;&lt;1|1
	inline void pushup(int i){
		tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn);
	}
	void Build(int i,int l,int r){
		tree[i].l=l,tree[i].r=r;
		if (l==r){
			tree[i].maxn=0x7fffffff;
			return ;
		}
		int mid=(l+r)&gt;&gt;1;
		Build(lc,l,mid);
		Build(rc,mid+1,r);
		pushup(i);
	}
	void Update(int i,int pos,int val){
		if (tree[i].l==tree[i].r){
			tree[i].maxn=val;
			return ;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1;
		if (pos&lt;=mid) Update(lc,pos,val);
		else Update(rc,pos,val);
		pushup(i);
	}
	int Query(int i,int L,int R){
		if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R){
			return tree[i].maxn;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff;
		if (L&lt;=mid) ans=max(ans,Query(lc,L,R));
		if (mid&lt;R) ans=max(ans,Query(rc,L,R));
		return ans;
	}
}
using namespace SegmentTree;
namespace Special_3{
	inline int Solve(int n,int q){
		//printf(&quot;coming into 3\n&quot;);
		Build(1,1,n);
		for (register int i=1;i&lt;=n;++i){
			if ((s[i]-'0')==1) Update(1,i,0);
		}
		for (register int t=1;t&lt;=q;++t) {
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				int ans=Query(1,l,r-1);
				if (ans==0x7fffffff) puts(&quot;0&quot;);//这条路上面有灯从未被点亮
				else printf(&quot;%d\n&quot;,t-ans); 
			}
			else {
				int i=qval[t];
				Update(1,i,t);
			}
		}
		return 0;
	}
}
namespace Special_2{
	int lst[MAX];//最后一次这个路灯被点亮的时刻
	int ans[MAX],a[MAX];
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0';
		for (register int i=1;i&lt;=n;++i) {
			if (a[i]==1) lst[i]=0;
			else lst[i]=-1;
		}
		for (register int t=1;t&lt;=q;++t){
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				printf(&quot;%d\n&quot;,ans[l]+(t-lst[l])*a[l]);
			}
			else {
				int pos=qval[t];
				a[pos]=!a[pos];
				if (a[pos]==0){
					ans[pos]+=t-lst[pos];
				}
				lst[pos]=t;
			}
		}
		return 0;
	}
}
namespace BruteForce{
	int a[MAXN][MAXN];
	inline void Copy(int i,int j,int n){//Copy i to j
		for (register int k=1;k&lt;=n;++k){
			a[j][k]=a[i][k];
		}
	}
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0';
		for (register int i=1;i&lt;=q;++i){
			Copy(i-1,i,n);
			if (cmd[i]==0){
				int l=ql[i],r=qr[i];
				int ans=0;
				for (register int j=0;j&lt;i;++j){
					bool flag=false;
					for (register int k=l;k&lt;r;++k){
						if (a[j][k]==0) {
							flag=true;break;
						}
					}
					if (flag==false){
						ans++;
					}
				}
				printf(&quot;%d\n&quot;,ans);
			}
			else {
				int pos=qval[i];
				a[i][pos]=!a[i][pos];
			}
		}
		return 0;
	}
}
int main(){
	int n=read(),q=read();
	scanf(&quot;%s&quot;,s+1);
	ReadQuerys(q);
	if (n&lt;=100&amp;&amp;q&lt;=100) return BruteForce::Solve(n,q);
	if (flag2) return Special_2::Solve(n,q);
	if (flag3) return Special_3::Solve(n,q);
	puts(&quot;you are a alb!&quot;);
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi>p</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100pts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span>思路：</p>
<p>不妨考虑打一个巨大的表（误，其中表的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>列表示询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的答案。</p>
<p>如何维护这个表，延续我们subtask2的思路，考虑到一个灯的贡献，如果它在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻被点亮，而在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时刻被熄灭，发现它对答案的贡献是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>−</mo><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_2-t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而这一个灯会对整个区间做出贡献，考虑加入一个灯，连成的全部被点亮的灯的区间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，灯的下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，那么这个灯的加入会对左端点在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>，右端点在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[x,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的询问造成贡献，熄灭也是同理。</p>
<p>关键问题来了，我们要对这个矩形加上多少，一个灯的贡献是它被点亮的所有时刻之和减去它被熄灭的所有时刻之和，所以亮起我们加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">t</span></span></span></span>，熄灭加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>，如果询问时两点已经联通，那么加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p>
<p>注意到我们很难处理区间修改，单点查询的问题，不妨做一次差分，变成区间查询，单点修改，可以CDQ分治或者树套树维护。</p>
<p>CDQ分治代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 300005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
void write(register int x){
	if (x&gt;=10) write(x/10);
	putchar(x%10+'0');
}
int m;
namespace BIT{
	int C[MAXN];
	#define lowbit(x) (x&amp;(-x))
	inline int Query(int k){
		int ans=0;
		for (register int i=k;i&gt;=1;i-=lowbit(i)){
			ans+=C[i];
		}
		return ans;
	}
	inline void Update(int k,int val){
		for (register int i=k;i&lt;MAXN;i+=lowbit(i)){
			C[i]+=val;
		}
	}
}
using namespace BIT;

struct node{
	int t,x,y,id;
	int type,val,ans;
};
node F[MAXN*4];
int tot,n;
inline void Add(int tim,int type,int x,int y,int val,int id){
	F[++tot].t=tim;
	F[tot].x=x;
	F[tot].y=y;
	F[tot].type=type;
	F[tot].val=val;
	F[tot].id=id;
	F[tot].ans=0;
}
inline bool cmp1(const node &amp;A,const node &amp;B){
	if (A.t!=B.t) return A.t&lt;B.t;
	if (A.x!=B.x) return A.x&lt;B.x;
	return A.y&lt;B.y;
}
inline bool cmp2(const node &amp;A,const node &amp;B){
	if (A.x!=B.x) return A.x&lt;B.x;
	return A.y&lt;B.y;
}
inline bool cmp3(const node &amp;A,const node &amp;B){
	return A.y&lt;B.y;
}
node tempF[MAXN*4];
inline void Msort(int l,int r){
	int mid=(l+r)/2;
	int j=l,k=mid+1;
	for (register int i=l;i&lt;=r;++i){
		if ((k&gt;r)||(j&lt;=mid&amp;&amp;cmp2(F[j],F[k]))) tempF[i]=F[j++];
		else tempF[i]=F[k++];
	}
	for (register int i=l;i&lt;=r;++i){
		F[i]=tempF[i];
	}
}
//1 query 2 update
void CDQ(int l,int r){
	if (l==r) return ;
	int mid=(l+r)&gt;&gt;1;
	CDQ(l,mid),CDQ(mid+1,r);
 	int p=l-1;
	for (register int i=mid+1;i&lt;=r;++i){
		while (p&lt;mid&amp;&amp;F[p+1].x&lt;=F[i].x){++p;if (F[p].type==2) Update(F[p].y,F[p].val);}
		if (F[i].type==1) F[i].ans+=Query(F[i].y);
	}
	for (register int i=l;i&lt;=p;++i){
		if (F[i].type==2) Update(F[i].y,-F[i].val);
	}
	Msort(l,r);
}
inline void AddRec(int tim,int x1,int y1,int x2,int y2,int val){
	Add(tim,2,x1-1,y1-1,val,0);
	Add(tim,2,x1-1,y2,-val,0);
	Add(tim,2,x2,y1-1,-val,0);
	Add(tim,2,x2,y2,val,0);
}
char s[MAXN];
set&lt;int&gt;S;
#define Iter set&lt;int&gt;::iterator
inline int GetPre(const int &amp;A){
	Iter it=S.lower_bound(A);
	return *--it;
}
inline int GetNex(const int &amp;A){
	Iter it=S.upper_bound(A);
	return *it;
}
int Ans[MAXN];
int main(){
	n=read(),m=read();
	scanf(&quot;%s&quot;,s+1);
	for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i);
	S.insert(0);
	S.insert(n+1);
	int cntq=0;
	char opr[10];
	for (register int i=1;i&lt;=m;++i){
		scanf(&quot;%s&quot;,opr);
		if (opr[0]=='q'){
			int l=read(),r=read();
			Add(i,1,l,r-1,0,++cntq);
			if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') Ans[cntq]+=i;
		}
		else {
			int pos=read();
			s[pos]=s[pos]=='1'?'0':'1';
			if (s[pos]=='1'){//联通
				int l=GetPre(pos)+1,r=GetNex(pos)-1;
				S.erase(pos);
				AddRec(i,l+1,pos+1,pos+1,r+1,-i);
			}
			else {
				int l=GetPre(pos)+1,r=GetNex(pos)-1;
				S.insert(pos);
				AddRec(i,l+1,pos+1,pos+1,r+1,i);
			}
		}
	}
	sort(F+1,F+1+tot,cmp1);
	CDQ(1,tot);
	for (register int i=1;i&lt;=tot;++i){
		if (F[i].type==1){
			Ans[F[i].id]+=F[i].ans;
		}
	}
	for (register int i=1;i&lt;=cntq;++i){
		printf(&quot;%d\n&quot;,Ans[i]);
	}
}
</code></pre>
<p>树套树代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 300005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
void write(register int x){
	if (x&gt;=10) write(x/10);
	putchar(x%10+'0');
}


int rt[MAXN];
namespace SegmentTree{
    struct node{
        int l,r;
        int val;
    }tree[MAXN*50];
    int tot;
    #define lc tree[i].l
    #define rc tree[i].r
    inline void pushup(int i){
        tree[i].val=tree[lc].val+tree[rc].val;
    }
    void Update(int &amp;i,int pos,int val,int l,int r){
        if (!i) i=++tot;
        if (l==r){
            tree[i].val+=val;
            return ;
        }
        int mid=(l+r)&gt;&gt;1;
        if (pos&lt;=mid) Update(lc,pos,val,l,mid);
        else Update(rc,pos,val,mid+1,r);
        pushup(i);
    }
    int Query(int i,int L,int R,int l,int r){
        if (L&lt;=l&amp;&amp;r&lt;=R){
            return tree[i].val;
        }
        int mid=(l+r)&gt;&gt;1,ans=0;
        if (L&lt;=mid) ans+=Query(lc,L,R,l,mid);
        if (mid&lt;R) ans+=Query(rc,L,R,mid+1,r);
        return ans;
    }
}
using namespace SegmentTree;

#define lowbit(x) (x&amp;-x)
inline void Add(int x,int y,int val){
    for (register int i=x;i&lt;MAXN;i+=lowbit(i)){
        Update(rt[i],y,val,1,MAXN-1);
    }
}
inline int Ask(int x,int y){
    int ans=0;
    for (register int i=x;i&gt;0;i-=lowbit(i)){
        ans+=Query(rt[i],1,y,1,MAXN-1);
    }
    return ans;
}

int n,m;
inline void AddRec(int x1,int y1,int x2,int y2,int val){
	Add(x1-1,y1-1,val);
	Add(x1-1,y2,-val);
	Add(x2,y1-1,-val);
	Add(x2,y2,val);
}
char s[MAXN];
set&lt;int&gt;S;
#define Iter set&lt;int&gt;::iterator
inline int GetPre(const int &amp;A){
	Iter it=S.lower_bound(A);
	return *--it;
}
inline int GetNex(const int &amp;A){
	Iter it=S.upper_bound(A);
	return *it;
}
int Ans[MAXN];
int main(){
	n=read(),m=read();
	scanf(&quot;%s&quot;,s+1);
	for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i);
	S.insert(0);
	S.insert(n+1);
	int cntq=0;
	char opr[10];
	for (register int i=1;i&lt;=m;++i){
		scanf(&quot;%s&quot;,opr);
		if (opr[0]=='q'){
			int l=read(),r=read();
			int ans=Ask(l,r-1);
			if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') ans+=i;
			printf(&quot;%d\n&quot;,ans);
		}
		else {
			int pos=read();
			s[pos]=s[pos]=='1'?'0':'1';
			if (s[pos]=='1'){//联通
				int l=GetPre(pos)+1,r=GetNex(pos)-1;
				S.erase(pos);
				AddRec(l+1,pos+1,pos+1,r+1,-i);
			}
			else {
				int l=GetPre(pos)+1,r=GetNex(pos)-1;
				S.insert(pos);
				AddRec(l+1,pos+1,pos+1,r+1,i);
			}
		}
	}
}
</code></pre>
<p>卡常代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define MAXN 205
#define MAX 300005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
void write(register int x){
	if (x&gt;=10) write(x/10);
	putchar(x%10+'0');
}
inline void Print(int x){
	if (x==0) puts(&quot;0&quot;);
	else write(x),putchar('\n');
}
/*
把询问离线下来 
*/
int cmd[MAX],ql[MAX],qr[MAX],qval[MAX],vis[MAX];
char opr[10],s[MAX];
bool flag2,flag3;
inline void ReadQuerys(int q){
	flag2=flag3=true;
	for (register int i=1;i&lt;=q;++i){
		scanf(&quot;%s&quot;,opr);
		if (opr[0]=='q'){
			cmd[i]=0;
			int l=read(),r=read();
			if (r!=l+1) flag2=false;
			ql[i]=l,qr[i]=r;
		}
		else {
			cmd[i]=1;
			int pos=read();
			if (vis[pos]==1) flag3=false;
			vis[pos]=1;
			qval[i]=pos;
		}
	}
}
namespace SegmentTree{
	struct node{
		int l,r;
		int maxn;
	}tree[1000005*4];
	#define lc i&lt;&lt;1
	#define rc i&lt;&lt;1|1
	inline void pushup(int i){
		tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn);
	}
	void Build(int i,int l,int r){
		tree[i].l=l,tree[i].r=r;
		if (l==r){
			tree[i].maxn=0x7fffffff;
			return ;
		}
		int mid=(l+r)&gt;&gt;1;
		Build(lc,l,mid);
		Build(rc,mid+1,r);
		pushup(i);
	}
	void Update(int i,int pos,int val){
		if (tree[i].l==tree[i].r){
			tree[i].maxn=val;
			return ;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1;
		if (pos&lt;=mid) Update(lc,pos,val);
		else Update(rc,pos,val);
		pushup(i);
	}
	int Query(int i,int L,int R){
		if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R){
			return tree[i].maxn;
		}
		int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff;
		if (L&lt;=mid) ans=max(ans,Query(lc,L,R));
		if (mid&lt;R) ans=max(ans,Query(rc,L,R));
		return ans;
	}
}
using namespace SegmentTree;
namespace Special_3{
	inline int Solve(int n,int q){
		Build(1,1,n);
		for (register int i=1;i&lt;=n;++i){
			if ((s[i]-'0')==1) Update(1,i,0);
		}
		for (register int t=1;t&lt;=q;++t) {
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				int ans=Query(1,l,r-1);
				if (ans==0x7fffffff) puts(&quot;0&quot;);//这条路上面有灯从未被点亮
				else Print(t-ans); 
			}
			else {
				int i=qval[t];
				Update(1,i,t);
			}
		}
		return 0;
	}
}
namespace Special_2{
	int lst[MAX];//最后一次这个路灯被点亮的时刻
	int ans[MAX],a[MAX];
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0';
		for (register int i=1;i&lt;=n;++i) {
			if (a[i]==1) lst[i]=0;
			else lst[i]=-1;
		}
		for (register int t=1;t&lt;=q;++t){
			if (cmd[t]==0){
				int l=ql[t],r=qr[t];
				Print(ans[l]+(t-lst[l])*a[l]);
			}
			else {
				int pos=qval[t];
				a[pos]=!a[pos];
				if (a[pos]==0){
					ans[pos]+=t-lst[pos];
				}
				lst[pos]=t;
			}
		}
		return 0;
	}
}
namespace BruteForce{
	int a[MAXN][MAXN];
	inline void Copy(int i,int j,int n){//Copy i to j
		for (register int k=1;k&lt;=n;++k){
			a[j][k]=a[i][k];
		}
	}
	inline int Solve(int n,int q){
		for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0';
		for (register int i=1;i&lt;=q;++i){
			Copy(i-1,i,n);
			if (cmd[i]==0){
				int l=ql[i],r=qr[i];
				int ans=0;
				for (register int j=0;j&lt;i;++j){
					bool flag=false;
					for (register int k=l;k&lt;r;++k){
						if (a[j][k]==0) {
							flag=true;break;
						}
					}
					if (flag==false){
						ans++;
					}
				}
				Print(ans);
			}
			else {
				int pos=qval[i];
				a[i][pos]=!a[i][pos];
			}
		}
		return 0;
	}
}
namespace Correct{
	int Max;
	namespace BIT{
		int C[MAX];
		#define lowbit(x) (x&amp;(-x))
		inline int Query(int k){
			int ans=0;
			for (register int i=k;i&gt;=1;i-=lowbit(i)){
				ans+=C[i];
			}
			return ans;
		}
		inline void Update(int k,int val){
			for (register int i=k;i&lt;=Max;i+=lowbit(i)){
				C[i]+=val;
			}
		}
	}
	using namespace BIT;
	
	struct node{
		int t,x,y,id;
		int type,val,ans;
	};
	node F[MAX*4];
	int tot;
	inline void Add(int tim,int type,int x,int y,int val,int id){
		F[++tot].t=tim;
		F[tot].x=x;
		F[tot].y=y;
		F[tot].type=type;
		F[tot].val=val;
		F[tot].id=id;
		F[tot].ans=0;
	}
	inline bool cmp1(const node &amp;A,const node &amp;B){
		if (A.t!=B.t) return A.t&lt;B.t;
		if (A.x!=B.x) return A.x&lt;B.x;
		return A.y&lt;B.y;
	}
	inline bool cmp2(const node &amp;A,const node &amp;B){
		if (A.x!=B.x) return A.x&lt;B.x;
		return A.y&lt;B.y;
	}
	inline bool cmp3(const node &amp;A,const node &amp;B){
		return A.y&lt;B.y;
	}
	node tempF[MAX*4];
	inline void Msort(int l,int r){
		int mid=(l+r)/2;
		int j=l,k=mid+1;
		for (register int i=l;i&lt;=r;++i){
			if ((k&gt;r)||(j&lt;=mid&amp;&amp;cmp2(F[j],F[k]))) tempF[i]=F[j++];
			else tempF[i]=F[k++];
		}
		for (register int i=l;i&lt;=r;++i){
			F[i]=tempF[i];
		}
	}
	void CDQ(int l,int r){
		if (l==r) return ;
		int mid=(l+r)&gt;&gt;1;
		CDQ(l,mid),CDQ(mid+1,r);
	 	int p=l-1;
		for (register int i=mid+1;i&lt;=r;++i){
			while (p&lt;mid&amp;&amp;F[p+1].x&lt;=F[i].x){++p;if (F[p].type==2) Update(F[p].y,F[p].val);}
			if (F[i].type==1) F[i].ans+=Query(F[i].y);
		}
		for (register int i=l;i&lt;=p;++i){
			if (F[i].type==2) Update(F[i].y,-F[i].val);
		}
		Msort(l,r);
	}
	inline void AddRec(int tim,int x1,int y1,int x2,int y2,int val){
		Add(tim,2,x1-1,y1-1,val,0);
		Add(tim,2,x1-1,y2,-val,0);
		Add(tim,2,x2,y1-1,-val,0);
		Add(tim,2,x2,y2,val,0);
	}
	set&lt;int&gt;S;
	#define Iter set&lt;int&gt;::iterator
	inline int GetPre(const int &amp;A){
		Iter it=S.lower_bound(A);
		return *--it;
	}
	inline int GetNex(const int &amp;A){
		Iter it=S.upper_bound(A);
		return *it;
	}
	int Ans[MAX];
	inline int Solve(int n,int q){
		Max=q;
		for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i);
		S.insert(0);
		S.insert(n+1);
		int cntq=0;
		for (register int i=1;i&lt;=q;++i){
			if (cmd[i]==0){
				int l=ql[i],r=qr[i];
				//printf(&quot;l,r: %d %d\n&quot;,l,r);
				Add(i,1,l,r-1,0,++cntq);
				if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') Ans[cntq]+=i;
			}
			else {
				int pos=qval[i];
				//printf(&quot;%d\n&quot;,pos);
				s[pos]=s[pos]=='1'?'0':'1';
				if (s[pos]=='1'){
					int l=GetPre(pos)+1,r=GetNex(pos)-1;
					S.erase(pos);
					AddRec(i,l+1,pos+1,pos+1,r+1,-i);
				}
				else {
					int l=GetPre(pos)+1,r=GetNex(pos)-1;
					S.insert(pos);
					AddRec(i,l+1,pos+1,pos+1,r+1,i);
				}
			}
		}
		sort(F+1,F+1+tot,cmp1);
		CDQ(1,tot);
		for (register int i=1;i&lt;=tot;++i){
			if (F[i].type==1){
				Ans[F[i].id]+=F[i].ans;
			}
		}
		for (register int i=1;i&lt;=cntq;++i){
			Print(Ans[i]);
		}
		return 0;
	}
} 
int main(){
	int n=read(),q=read();
	scanf(&quot;%s&quot;,s+1);
	ReadQuerys(q);
	if (n&lt;=100&amp;&amp;q&lt;=100) return BruteForce::Solve(n,q);
	if (flag2) return Special_2::Solve(n,q);
	if ((n!=500||q!=300000)&amp;&amp;flag3) return Special_3::Solve(n,q);
	return Correct::Solve(n,q);
	return 0;
}
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://steven-mhy.github.io/post/BZOJ-4987-Tree">
              <h3 class="post-title">
                下一篇：BZOJ 4987 Tree
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">白鳥は　かなしからずや　空の青 海のあをにも　染まずただよふ</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://steven-mhy.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0381bd48f354d449038e',
        clientSecret: 'a325a1b671eb2071d75fc107561dfeedaa1485cf',
        repo: 'steven-mhy.github.io',
        owner: 'steven-mhy',
        admin: ['steven-mhy'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
